---
title: "Sampling"
format: html
editor: visual
---

# Sampling CE

```{r, message = FALSE, warning = FALSE}
if (!require(tidyverse)) install.packages("tidyverse"); library(tidyverse)
if (!require(rpms)) install.packages("rpms"); library(rpms)
if (!require(sampling)) install.packages("sampling"); library(sampling)
```

## Filtering & EDA

First, we need to get to our population to sample from by filtering and doing a small exploratory data analysis to justify our selection.

```{r}
ce = rpms::CE %>%
  filter(SALARYX < 250000 & SALARYX > 0) %>%
  filter(TOTEXPCQ > 0 & FINCBTAX > 0 & !is.na(REGION))

ggplot(ce, aes(log(TOTEXPCQ), log(FINCBTAX))) + 
  geom_point(alpha = 0.05) + 
  geom_smooth(method = "lm")

test = lm(log(FINCBTAX) ~ log(TOTEXPCQ), ce)
summary(test)
```

## Sampling

Now, we need to start constructing our sampling techniques

```{r}
# I want to call a single sampling function then choose which method
# Returning, I want the sampled dataframe with weights

sampling <- function(dataset, sample_size, method, variable = NULL, nh = NULL, noise_sd = NULL) {
  # Check if mandatory parameters are correct
  stopifnot(is.numeric(sample_size)) 
  stopifnot(is.character(method) & method %in% c("grouping", "pps", "region_strata", "srs"))
  stopifnot(is.data.frame(dataset))
  
  # Extract column vector
  data = NULL
  if (variable %in% names(dataset)) {
    data = dataset[[variable]]
  } else {
    if (method != "srs") { # SRS is the only method that does not need a variable
      stopifnot(is.character(variable))
      stop(paste("The dataset does not contain a column named", variable))
    }
  }
  
  # Calulate inclusion probabilities
  pik = NULL
  if (method == "grouping") {
    pik = grouping(data = data, nh = nh)
  } 
  if (method == "pps") {
    pik = pps(data = data, n = sample_size, noise_sd = noise_sd)
  } 
  if (method == "region_strata") {
    pik = region_strata(data = data, nh = nh)
  } 
  if (method == "srs") {
    pik = srs(n = sample_size, N = length(dataset))
  }
  
  # Add weights to dataset for later
  dataset$wts = pik^(-1)
  
  # Sample vector using pik
  # Why does UPsampford take so long to sample?
  sample_vector = UPsampford(pik, max_iter = sample_size)
  
  # Return data
  return(sample_data)
}

# fix bug
y = sampling(dataset = ce, sample_size = 150, method = "grouping", nh = c(10, 15, 25, 50), variable = "FINCBTAX", noise_sd = 0.05)

x = ce[y,]
```





### Grouping

```{r}
# data - numerical vector from which to group and create stratum
# nh - vector of the number of selected units in each stratum

# People might want to do grouping based on multiple factors / nums TO-DO
# Consider using interaction() for multiple cuts

# Might be wise to group based on multiple factors since weights will be very large

grouping <- function(data, nh) {
  N = length(nh) # Number of stratum
  groups = cut(data, breaks = quantile(data, probs = seq(0, 1, 1 / N)),
                     include.lowest = TRUE,
                     labels = FALSE)
  pik = inclusionprobastrata(groups, nh)
  return(pik)
}

sample_size = 100
strata_prob = c(0.1, 0.15, 0.25, 0.5)

ce$pik = grouping(data = ce$FINCBTAX, nh = sample_size * strata_prob)
```


### Probability Proportional to Size (PPS)

With sampling with the inclusion probabilities proportional to size (PPS), an element of randomness is added to the sampling to account for some variability. Since PPS is positive-definite, it is problematic to suggest an additive random noise process $Z_i = Y_i + \varepsilon_i, \forall i$ where $Z_i$ is the observed response variable, $Y_i$ is the signal derived from the dataset, and $\varepsilon$ is the noise term. Without imposing arbitrary distributional characteristics to $\varepsilon$ to ensure $Z_i > 0$ for all $i$, we should consider a multiplicative regression $$Z_i = Y_i * (1 + \varepsilon_i).$$ Let $\varepsilon \overset{iid}{\sim} \mathcal{N}(0, \sigma^2)$. Then $$E(Z) = E(Y * (1 + \varepsilon)) = E(Y + Y \varepsilon) = E(Y) + E(Y \varepsilon) = E(Y) = Y, \text{ by } Y \perp\!\!\!\!\perp \varepsilon.$$

\begin{align*}
  \text{Var}(Z) &= \text{Var}(Y * (1 + \varepsilon)) \\ 
  &= \text{Var}(Y) + \text{Var}(Y \varepsilon) + 2 \text{Cov}(Y, Y \varepsilon).
\end{align*}

\begin{equation*}
  \text{Cov}(Y, Y \varepsilon) = E(Y^2 \varepsilon) - E(Y)^2 E(\varepsilon) = E(Y^2) E(\varepsilon) = 0
\end{equation*}

\begin{align*}
  \text{Var}(Y \epsilon) &= \text{Var}(E(Y \varepsilon \mid Y)) + E(\text{Var}(Y \epsilon \mid Y)) \\
  &= \text{Var}(Y E(\varepsilon \mid Y)) + E(Y^2 \text{Var}(\varepsilon \mid Y)) \\
  &= \text{Var}(Y E(\varepsilon)) + E(Y^2 \text{Var}(\varepsilon)) \\
  &= E(\varepsilon)^2 \text{Var}(Y) + E(Y^2) \text{Var}(\varepsilon) \\
  &= E(Y^2) \text{Var}(\varepsilon).
\end{align*}

\begin{align*}
  \text{Var}(Z) &= \text{Var}(Y) + \text{Var}(Y \varepsilon) + 2 \text{Cov}(Y, Y \varepsilon) \\
  &= \text{Var}(Y) + E(Y^2) \text{Var}(\varepsilon).
\end{align*}

For some small Var$(\varepsilon)$, we will not have to worry about an extremely low case of $Z = 0$ for some $i$ which ensures variation onto $Y$ and positive $Z$.

```{r}
pps <- function(data, n, noise_sd) {
  stopifnot(is.numeric(noise_sd))
  
  noise = rnorm(length(data), 0, noise_sd)
  data_noisy = data * (1 + noise)
  pik = inclusionprobabilities(data_noisy, n)
  return(pik)
}

#pps(ce$FINCBTAX, 1000, noise_sd = 0.05)
```

### Stratify on Region

```{r}
region_strata <- function(data, nh) {
  pik = inclusionprobastrata(as.numeric(data), nh)
  return(pik)
}

strata_prop = c(150, 150, 500, 200)
#region_strata(data = ce$REGION, nh = strata_prop)
```


### Control

```{r}
srs <- function(n, N) {
  pik = rep(n / N, N)
  return(pik)
}

#srs(10, 100)
```
